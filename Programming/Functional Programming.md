## General course info
Lections + some practice (problems).
1 problem per week. Solution in Clojure in functional programming style.

All problems - pre C mark 
2nd part - project for 2 students - pre B, A + exam (+-1 ball max)

Literature:
![[literature_list.png]]
## General about programming
*Язык программирования* - инструмент для общения с машной.
Состав языка:
- *Синтаксис* - из каких элементов состоит язык
- *Семантика* - смысл элементов
- *Прагматика* - правила их применения

### Модель исполнения языка
- Интерпретируемый (Python, JavaScript, PHP)
	- Непосредственно исполняет код
	- Транслирует код в промежуточное представление и исполняет
	- Сначала транслирует с созданием промежуточных файлов и исполняет в явном виде (Java)
- Компилируемый (C, C++)

### По назначению
	- Общего назначения (C++, Java, C#)
	- Языки сценариев (Python)
	- Представления данных (XML, JSON)
	- Языки запросов (SQL, XPath) 
	- DSL

### Динамические языки
	- Компиляция во время исполнения
	- Динамическая типизация
	- Динамическая генерация кода

### Виды типизации 
- По времени проверки типа
	- Статическая (во время компиляции)
	- Динамическая (во время исполнения)
- По строгости проверки типа 
	- Сильная (Python, т.к. на рантайме известен тип)
	- Слабая (asm, c через void*)

### Принципы разработки ПО
Два основных принципа:
- Разделение ответственностей (SoC - Separation of concerns) - программа должна состоять из функц. блоков, как можно меньше дублирующих функциональность друг друга. DRY (Don't repeat yourself)
- KISS (Keep it simple)

### Парадигмы программирования
*Парадигма программирования* - это совокупность принципов, методов и понятий, определяющих способ конструирования программ. 
Парадигма определяет:
- Вычислительная модель
	- машина тьюринга (императивное программирование)
	- лямбда исчисление (функциональное программирование)
	- метод резолюций (логическое программирование)
	- и др. например в SQL модель реляционной алгебры
- базовая программная единица (объект)
- метод разделения абстракций (ответственности)

**Императивное программировние**
	Выч. модель - машина тьюринга
	Основные механизмы управления / абстракции: последовательный переход, безусловный переход, ветвления, вызов подпрограмм
	Пример - ассемблер
	
**Структурное программирование**
	Императивное + циклы, лексический контекст (область видимости), подпрограммы с изолированным контекстом
	Пример - Си
	
### Лямбда исчисление
![[lambda func.png]]
![[lambda poryadok.png]]




### Функциональное программирование (чистое)

Представление программы в форме набора чистых функций (без побочных эффектов, она может только получать аргументы и вычислять значения).
Вместо циклов используется рекурсия. 
Функция сама по себе - объект первого класса, ее можно передавать как аргумент, возвращать и т.д. 
Вычислительная модель - лямбда исчисление.
Преимущества ФП:
- Минимальный уровень сокрытия ошибок (из-за отсутствия изменяемых переменных)
- Выразителен для алгоритмов 
- Эффективная поддержка параллелизма 
- Поддержка мемоизации, отложенных вычислений
## Clojure
Modern interpretation of Lisp PL. 

### Немного о Lisp
Первый динамический, перый функциональный язык, перый со сборщиком мусора, первый с абстрактными типами данных (список), первый язык представления данных, первая среда с REPL (Repeat evaluation print repeat).
### Синтаксис Lisp

Атом - недилимая сущность (символ, константа):
- идентификатор
- константа (строка, число)
S-выражения (S(-symbolic)-expression) - выражения вида a1 или (a1 a2 ... ), где a1 a2 либо атомы, либо другие S-выражения.
(f a b c) // как f (a, b, c) в си

Итерпретация S-выражения
Вычисляет первый элемент списка, результат вычислений должен быть либо функцией, либо специальной формой.

*Функция* - вычисляются все последующие элементы списка, после чего происходит вызов функции (аппликативный порядок вычислений).

*Специальная форма* - происходит вызов специальной формы без вычисления аргументов. Спец. форма сама инициирует вычисление аргументов (отложенный порядок вычислений). Примеры: управляющие конструкции, логические связки. 



### О Clojure

Первый релиз - 2009 г.
Автор - Richard Hickey
Платформа: JVM (компилируется в JBC)
Классификация: диалект Lisp промышленного назначения
Особенности: чистая функциональная основа, эффективная многопоточность

Сборка:
Leiningen 

### Особенности записи арифметических операций

В Lisp нет арифметических (и других) операторов. Все операции являются вызовами функций (или спец. форм) и записываются в префиксной форме. 
Отсутствует приоритет операций, т.к. оно имеет смысл только для инфиксной записи. 
C: `a*x*x + b*x + c`
Lisp: `(+ (* a x x) (* b x) c)`

### Опеределение функций

```clojure
(defn fname doc? [args] prepostmap? forms)

(comment 
 fname - имя функции
 doc - документация
 args - список аргументов
 prepostmap? - пре,пост условия
 forms - тело, одно или несколько S-выражений)

(defn sqr
	"Square" ; optional
	[x]
	(:pre [(>= x 0)]) ;optional
	(* x x))

(defn fact [n]
	(if (> n 0)
	(* n (fact (dec n)))
	1))

;"Перегрузка" функций 
; делается под одной дефеницией 

(defn sum
	([] 0)
	([x] x)
	([x y & rest]
		(+ x (apply sum (cons y rest)))))

; анонимные функции

((fn [x] (+ x 5)) 3) ; определение анонимной функции и ее применение 
(#(+ % 5) 3) ; эквивалентная сокращенная запись. не рекомендуется. % подставляет 1 аргумент

; функция с переменных кол-вом параметров


```

### Типы
Числа
```clojure
(println (/ 1.0 2.0)) ; >> 0.5
(println (/ 1 2)) ; >> 1/2
(println (+ 1/2 1/3) ; >> 5/6		
```

Строки
Как в Java
```clojure
"Some" ; строка
#"[\w\s]+" ; regex
(println (class "Some String")); >> java.lang.String
(println (.toUpperCase "Some String")) ; вызов метода
```

Переменные (определение лексического контекста)
```clojure
;let определяет и привязывает значеник к символам

(let [a 10, ; тут запятая разделительная как пробел, ее можно убрать
	  b (+ a 10)]
	(print a)
	(print b))

(letfn [(my-f [x] (+ 5 x))]
	(my-f 6))

(let [my-f (fn [x] (+ 5 x))] ;тоже самое
	(my-f 6))
; loop - эквивалетно let, но при этом определяется точка возврата для recur

```

Списки 
Один из базовых типов 
```clojure
(f a b) ; любое скобочное выражение интерпретируется как список и его вычисление

(list a, b, c) ; определение списка
'(a b c) ; блокирует вычисление списка

(cons 'a '(b c)) ; -> (a b c) construct
(conj '(b c) 'a) ; -> (a b c) conjoin
(concat '(a b) '(b c))

; Доступ к элементам

(first '(a b c)) ; -> a
(rest '(a b c)) ; -> (b c)
(nth 2 '(a b c)) ; -> c
(take 2 '(a b c)) ; (a b)
```

**Вычисление над списками**
В императивных языках используется цикл, список модифицируется по мере итерации, накопление результата в переменной

В функциональных языках списки неизменяемые, в чистом виде используется рекурсия с разделением "головы" и "хвоста" списка, в рекурсивный вызов передается "хвост" и, при необходимости, результаты промежуточных вычислений.

```clojure
(defn inc-coll-1 [coll]
	(if (> count coll) 0)
	(cons (inc (first coll)) ; применяем к голове inc и собираем вместе через cons 
	(inc-coll-1 (rest coll))) ; рекурсия над хвостом
	(list))) ; возвращем список

(defn fact-1 [n]
	(if (> n 0)
	(* n (fact-1 (dec n)))
	1))
```

В ФП практическом используются трансформирующие функции высшего порядка для списков.

Ветвление

```clojure
(if 
	(> a 0) ; cond
	(print "yes") ;then 
	(print "no") ; else
	)
(println
 (cond 
	 (> a 0) "pos"
	 (< a 0) "neg"
	 true "nil")) ; вместо true можно хоть что не равное 0 nil
```

Взаимодействие с Java

```clojure
(class "Test") ; -> java.lang.String
(.toUpperCase "abc") ; можно вызывать методы над объектами Java
(. "abc" toUpperCase) ; можно так
(.concat "ab" "cd") ; -> "abcd"

(ns ru.nsu.fit.dt ; namespace - тоже самое что пакет в джава
	;clojure namespace
	(:use clojure.test)
	(:import (java.io File PrintWriter))
	)

; / разделяет индентификатор метода, статического поля
(clojure.xml/parse "file.xml")
(Math/sin Math/PI)
(set! MyClass/someStaticVar 42) ; функия set! для присваивания 
(new HashMap) ; конструктор
(.. "str" (getClass) (getName)) ; java.lang.String цепочка вызовов
(.getName (.getClass "str")) ; тоже самое

(doto (new HashMap) (.put "a" 1) (.put "b" 2)) ; последоватльный вызов
(let [m (new HashMap)]
	(.put m "a" 1)
	(.put m "b" 2)) ; в локальном контексте

```


### Символьные вычисления
**Правила вывода:**
Существуют правила вывода для:
- константы
- переменной
- суммы
- произведения
- 1 / f(x)
- exp(x)
Почти все правила вывода рекурсивны

**Реализация списка правил через шаблон Chain of responsibilities**

```clojure
(declare diff)
;список правил вывода
(def diff-rules
	(list 
		[pred1 transform1]
		[pred2 transform2]
		;...
		))
```

Реализация функции дифференцирования
```clojure
(defn diff [expr vr]
	((some (fn [rule]
				(if ((first rule) expr vr)
					(second rule)
					false))
			diff-rules)
	))
```

Правила вывода для констант и переменных
```clojure
; константа
[(fn [expr vr] (constant? expr)) 
 (fn [expr vr] (constant 0))]
; переменная дифференцирования
[(fn [expr vr] (and (variable? expr)
					(same-variables? expr vr)))
					(fn [expr vr] (constant 1))]
; другая переменная
[(fn [expr vr] (variable? expr))
 (fn [expr vr] (constant 0))]
```
Правила вывода для суммы
```clojure
[(fn [expr vr] (sum? expr))
 (fn [expr vr] 
	 (apply sum
	  (map 
		  #(diff % vr)
		 (args expr))))]
```
Правило для произведения
```clojure
(defn product [expr & rest]
	(if (empty? rest)
		expr
		(cons ::product (cons expr rest))))

[(fn [expr vr] (product? expr))
 (fn [expr vr]
	 (let [first-arg (first (args expr))
		 rest-prod
		 (apply product
			 (rest (args expr)))]
			 (sum
				 (product 
					 (diff first-arg vr) rest-prod)
				 (product first-arg
					 (diff rest-prod vr)))))]
```
Проблема: сумма, произведение
```clojure
(diff (sum (constant 2) (variable :x)
		   (variable :x))) ; 2 + x
>>
(::sum
	(::const 0)
	(::const 1))		  ; 0 + 1

(diff (product
	   (constant 2)
	   (variable :x))
	(variable :x))        ; 2x

>>
(::sum
	(::product
		(::const 0)
		(::var :x))
	(::product
		(::const 2)
		(::const 1))) 
		;0*x + 2*1
```
Модифицируем произведение
```clojure
(defn product [expr & rest]
	(let [normalized-exprs
			(collapse-prod-constants
				(cons expr rest))]
		(if (= 1 (count normalized-exprs))
			(first normalized-exprs)
			(cons ::product
				normalized-exprs))))
```